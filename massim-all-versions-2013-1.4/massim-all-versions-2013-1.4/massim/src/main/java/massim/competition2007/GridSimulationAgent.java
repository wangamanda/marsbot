package massim.competition2007;import java.util.Random;import massim.framework.Action;import massim.framework.AgentParameter;import massim.framework.FinalPerception;import massim.framework.InitialStickyPerception;import massim.framework.InvalidAction;import massim.framework.Perception;import massim.framework.UniqueSimulationAgent;import massim.framework.connection.UsernamePasswordAccount;import massim.framework.simulation.AgentState;import massim.framework.simulation.SimulationAgent;import massim.framework.simulation.WorldState;import massim.goldsimulations.GridSimulationAgentInitialPerception;import massim.goldsimulations.GridSimulationCell;import massim.goldsimulations.GridSimulationPerceptionCell;import massim.gridsimulations.AbstractGridSimulationAgentAction;import massim.gridsimulations.GridSimulationAgentFinalPerception;import massim.gridsimulations.SimulationAgentExtend;/** * This class deals with the agent state, his actions and perceptions. * */public class GridSimulationAgent extends SimulationAgentExtend {	private GridSimulationAgentState agentstate;	/**	 * The constructor instantiates the agentstate.	 */	public GridSimulationAgent() {		agentstate = new GridSimulationAgentState();	}	/*	 * (non-Javadoc)	 * 	 * @see massim.simulation.simplesimulation.SimulationAgent#getAgentState()	 */	public AgentState getAgentState() {		return agentstate;	}	/*	 * (non-Javadoc)	 * 	 * @see	 * massim.simulation.simplesimulation.SimulationAgent#setAgentParameter(	 * massim.AgentParameter)	 */	public void setAgentParameter(AgentParameter agentpar) {		super.setAgentParameter(agentpar);		// get Team		GridSimulationAgentParameter gridSimAgentParameter = (GridSimulationAgentParameter) agentpar;		agentstate.team = gridSimAgentParameter.getTeam().toString();		// get Username		if (this.getAgent() instanceof UniqueSimulationAgent) {			UniqueSimulationAgent agent = (UniqueSimulationAgent) this					.getAgent();			if (agent.getIdentifier() instanceof UsernamePasswordAccount) {				UsernamePasswordAccount upa = (UsernamePasswordAccount) agent						.getIdentifier();				agentstate.name = upa.getUsername();			}		}	}	/*	 * (non-Javadoc)	 * 	 * @see	 * massim.simulation.simplesimulation.SimulationAgent#createPerception(massim	 * .simulation.simplesimulation.WorldState,	 * massim.simulation.simplesimulation.AgentState[])	 */	public Perception createPerception(WorldState simstate,			AgentState[] agentstates) {		GridSimulationWorldState simulationstate = (GridSimulationWorldState) simstate;		GridSimulationAgentPerception p = new GridSimulationAgentPerception();		p.posx = agentstate.posx;		p.posy = agentstate.posy;		p.step = simulationstate.currentStep;		p.items = agentstate.currentItems;		Random r1 = new Random();		// information distortion and local view creation		p.cur = convertCell(simulationstate.board[p.posx][p.posy]);		if ((Math.abs(r1.nextInt()) % 100) < simulationstate.informationDistortionProbability) {			p.cur.unknown = true;		}		if (p.posy > 0) {			p.n = convertCell(simulationstate.board[p.posx][p.posy - 1]);			if ((Math.abs(r1.nextInt()) % 100) < simulationstate.informationDistortionProbability) {				p.n.unknown = true;			}		}		if (p.posy < simulationstate.sizey - 1) {			p.s = convertCell(simulationstate.board[p.posx][p.posy + 1]);			if ((Math.abs(r1.nextInt()) % 100) < simulationstate.informationDistortionProbability) {				p.s.unknown = true;			}		}		if (p.posx > 0) {			p.w = convertCell(simulationstate.board[p.posx - 1][p.posy]);			if ((Math.abs(r1.nextInt()) % 100) < simulationstate.informationDistortionProbability) {				p.w.unknown = true;			}		}		if (p.posx < simulationstate.sizex - 1) {			p.e = convertCell(simulationstate.board[p.posx + 1][p.posy]);			if ((Math.abs(r1.nextInt()) % 100) < simulationstate.informationDistortionProbability) {				p.e.unknown = true;			}		}		if (p.posx > 0 && p.posy > 0) {			p.nw = convertCell(simulationstate.board[p.posx - 1][p.posy - 1]);			if ((Math.abs(r1.nextInt()) % 100) < simulationstate.informationDistortionProbability) {				p.nw.unknown = true;			}		}		if (p.posx > 0 && p.posy < simulationstate.sizey - 1) {			p.sw = convertCell(simulationstate.board[p.posx - 1][p.posy + 1]);			if ((Math.abs(r1.nextInt()) % 100) < simulationstate.informationDistortionProbability) {				p.sw.unknown = true;			}		}		if (p.posx < simulationstate.sizex - 1 && p.posy > 0) {			p.ne = convertCell(simulationstate.board[p.posx + 1][p.posy - 1]);			if ((Math.abs(r1.nextInt()) % 100) < simulationstate.informationDistortionProbability) {				p.ne.unknown = true;			}		}		if (p.posx < simulationstate.sizex - 1				&& p.posy < simulationstate.sizey - 1) {			p.se = convertCell(simulationstate.board[p.posx + 1][p.posy + 1]);			if ((Math.abs(r1.nextInt()) % 100) < simulationstate.informationDistortionProbability) {				p.se.unknown = true;			}		}		return p;	}	public void processAction(Action a, WorldState simstate,			AgentState[] agentstates) {		//GridSimulationWorldState simulationstate = (GridSimulationWorldState) simstate;		// information distortion		GridSimulationAgentAction received = new GridSimulationAgentAction();		if (a instanceof InvalidAction) {			// set lastAction			agentstate.currentAction = "invalid";				} else if (a instanceof GridSimulationAgentAction) {			received = (GridSimulationAgentAction) a;			// caculate the success proability of action			this.filterFatique(received, simstate);			// set lastAction			agentstate.currentAction = received.type;			agentstate.param = received.param;		}			}	/**	 * take charge of agent's direction in world state. in the case, two or more	 * agents wants to move in the same cell, only one of them can move in and the	 * others will be set back to their old positions. in other words if the first agent 	 * wants to move to the cell, where another agent (also the second) stands. he will try to push the second agent 	 * away in a free cell .the push action can only success when the second agent does not want to 	 * perform a movement in his last simulation step and this simulation step(his actions can be "skip", "invalid" "pick", "drop",	 * "mark", "unmark").	 * when the first agent can not push the second. his action will be set as "skip"	 * 	 * @param simstate	 *            is the WorldState	 */		public void updateWorldState(WorldState simstate, SimulationAgent[] agents) {		// update worldstate		GridSimulationWorldState simulationstate = (GridSimulationWorldState) simstate;		boolean move_success = false;		agentstate.oldPosx = agentstate.posx;		agentstate.oldPosy = agentstate.posy;		agentstate.actionFailed = false;				if (agentstate.agentInDepot && agentstate.timeInDepot ==2) {						boolean teleported = false;			Random r = new Random();			while (!teleported) {				int x = Math.abs(r.nextInt()) % (simulationstate.sizex - 1);				int y = Math.abs(r.nextInt()) % (simulationstate.sizey - 1);				if ((!simulationstate.board[x][y].agent						&& !simulationstate.board[x][y].depot && !simulationstate.board[x][y].obstacle)) {					agentstate.posx = x;					agentstate.posy = y;					agentstate.lastAction ="skip";										simulationstate.board[agentstate.oldPosx][agentstate.oldPosy].agent = false;					simulationstate.board[agentstate.oldPosx][agentstate.oldPosy].agentTeam = null;					simulationstate.board[agentstate.posx][agentstate.posy].agent = true;					simulationstate.board[agentstate.posx][agentstate.posy].agentTeam = agentstate.team;					teleported = true;					agentstate.agentInDepot = false;					agentstate.timeInDepot = 0;				}			}			return;		}	/*********************************************************************/		// Perform action		if (agentstate.currentAction.equalsIgnoreCase("drop")				&& agentstate.agentHoldsGold				&& !simulationstate.board[agentstate.posx][agentstate.posy].gold) {			if (agentstate.agentInDepot) {				agentstate.score += agentstate.currentItems;				if (agentstate.team == simulationstate.teamName[0]) {					simulationstate.teamScore[0] += agentstate.currentItems;				} else {					simulationstate.teamScore[1] += agentstate.currentItems;				}				agentstate.currentItems = 0;				agentstate.agentHoldsGold = false;			} else {				simulationstate.numberOfGoldItems += 1;				simulationstate.board[agentstate.posx][agentstate.posy].gold = true;				agentstate.currentItems -= 1;				if (agentstate.currentItems == 0) {					agentstate.agentHoldsGold = false;				} else					agentstate.agentHoldsGold = true;			}		}		// Agent can pick up golds as much as his ability to carry them.		// maxNumberofCarriedGoldItems is the carry-ability of agent		else if (agentstate.currentAction.equalsIgnoreCase("pick")				&& !agentstate.agentInDepot				&& (agentstate.currentItems < simulationstate.maxNumberOfCarriedGoldItems)				&& simulationstate.board[agentstate.posx][agentstate.posy].gold) {			agentstate.agentHoldsGold = true;			agentstate.currentItems += 1;			simulationstate.board[agentstate.posx][agentstate.posy].gold = false;			simulationstate.numberOfGoldItems -= 1;		}		else if (agentstate.currentAction.equalsIgnoreCase("unmark")				&& !agentstate.agentInDepot) {			simulationstate.board[agentstate.posx][agentstate.posy].mark = false;		} else if (agentstate.currentAction.equalsIgnoreCase("mark")				&& !agentstate.agentInDepot) {			simulationstate.board[agentstate.posx][agentstate.posy].markText = agentstate.param					.substring(0, agentstate.param.length() % 4);			simulationstate.board[agentstate.posx][agentstate.posy].mark = true;		}		/******************************************************************/				// movement						else if (agentstate.currentAction.equalsIgnoreCase("up")				&& !collisionCheck(agentstate.posx, agentstate.posy - 1,						simulationstate.sizex, simulationstate.sizey,						simulationstate.board)) {			agentstate.posy -= 1;			move_success = processMovement(simulationstate, agents);					} else if (agentstate.currentAction.equalsIgnoreCase("down")				&& !collisionCheck(agentstate.posx, agentstate.posy + 1,						simulationstate.sizex, simulationstate.sizey,						simulationstate.board)) {			agentstate.posy += 1;			move_success = processMovement(simulationstate, agents);					} else if (agentstate.currentAction.equalsIgnoreCase("left")				&& !collisionCheck(agentstate.posx - 1, agentstate.posy,						simulationstate.sizex, simulationstate.sizey,						simulationstate.board)) {			agentstate.posx -= 1;			move_success = processMovement(simulationstate, agents);					} else if (agentstate.currentAction.equalsIgnoreCase("right")				&& !collisionCheck(agentstate.posx + 1, agentstate.posy,						simulationstate.sizex, simulationstate.sizey,						simulationstate.board)) {			agentstate.posx += 1;			move_success=processMovement(simulationstate, agents);		}				if(simulationstate.board[agentstate.posx][agentstate.posy].depot){			agentstate.agentInDepot = true;			if(!move_success)				agentstate.timeInDepot +=1;		}else {			agentstate.timeInDepot = 0;			agentstate.agentInDepot = false;		}				}	/**	 * agent tries to move in the wished cell. When there is already an another agent in the wished cell	 * this agent will try to push him away. 	 * Conditions to push an agent away:	 * when the current action and the last action of pushed agent are not move_action and	 * when the pushed agent is not in depot and	 * when there is at least a free cell around the pushed agent	 * 	 * When this agent can not perform his movement. his last action will be set as "skip"	 * 	 */	private boolean processMovement(GridSimulationWorldState simulationstate, SimulationAgent[] agents){		boolean sucess = false;				if(!simulationstate.board[agentstate.posx][agentstate.posy].agent){						//move  to free cell			simulationstate.board[agentstate.oldPosx][agentstate.oldPosy].agent = false;			simulationstate.board[agentstate.oldPosx][agentstate.oldPosy].agentTeam = null;			simulationstate.board[agentstate.posx][agentstate.posy].agent = true;			simulationstate.board[agentstate.posx][agentstate.posy].agentTeam = agentstate.team;			agentstate.lastAction = agentstate.currentAction;			agentstate.wasPushed = false;					 sucess= true;					}		// when there is a agent in moving cell, this agent will try to push him		// away				else {			// check now for pushing the agent away			// when the pushed agent do not make any movement (action = "skip"			// or "invalid").			// he will be pushed			for (int i = 0; i < agents.length; i++) {				GridSimulationAgentState pushedAgent_state = (GridSimulationAgentState) agents[i]						.getAgentState();				//find the agent to push				if(pushedAgent_state.posx == this.agentstate.posx						&& pushedAgent_state.posy == this.agentstate.posy){										String pushDirection = pushDirection(simulationstate,pushedAgent_state.posx, pushedAgent_state.posy);					//try to push					if (!moveAction(pushedAgent_state.currentAction) && !moveAction(pushedAgent_state.lastAction)							&& !pushDirection.equalsIgnoreCase("NO")							&& !pushedAgent_state.agentInDepot) {												int x = pushedAgent_state.posx;						int y = pushedAgent_state.posy;						if (pushDirection.equalsIgnoreCase("up")) {							pushedAgent_state.posy -=1;						} else if (pushDirection.equalsIgnoreCase("down")) {							pushedAgent_state.posy +=1;						} else if (pushDirection.equalsIgnoreCase("left")) {							pushedAgent_state.posx -=1;						} else if (pushDirection.equalsIgnoreCase("right")) {							pushedAgent_state.posx +=1;						}						//push action						simulationstate.board[x][y].agent = false;						simulationstate.board[x][y].agentTeam = null;						simulationstate.board[pushedAgent_state.posx][pushedAgent_state.posy].agent = true;						simulationstate.board[pushedAgent_state.posx][pushedAgent_state.posy].agentTeam = pushedAgent_state.team;						pushedAgent_state.lastAction = pushDirection;						pushedAgent_state.wasPushed = true;												//move action						simulationstate.board[agentstate.oldPosx][agentstate.oldPosy].agent = false;						simulationstate.board[agentstate.oldPosx][agentstate.oldPosy].agentTeam = null;						simulationstate.board[agentstate.posx][agentstate.posy].agent = true;						simulationstate.board[agentstate.posx][agentstate.posy].agentTeam = agentstate.team;						agentstate.lastAction = agentstate.currentAction;						agentstate.wasPushed = false;												sucess = true;						break;					}					else {						// in this case the agent in moving cell can not be pushed, so that this agent 						// can not perform his movement.						agentstate.posx = agentstate.oldPosx;						agentstate.posy = agentstate.oldPosy;						agentstate.lastAction = "skip";						sucess = false;											}									}			}		}		return sucess;	}			private String pushDirection(GridSimulationWorldState simulationstate,int x , int y){		if(canPush(simulationstate, "up", x, y)) return "up";		else if(canPush(simulationstate, "down", x, y)) return "down";		else if(canPush(simulationstate, "left", x, y)) return "left";		else if(canPush(simulationstate, "right", x, y)) return "right";		else return "NO";			}	/**	 * Test, if pushing possible	 * 	 * @param nextAction	 * @param x	 * @param y	 * @return	 */	public boolean canPush(GridSimulationWorldState simulationstate,			String nextAction, int x, int y) {		if (nextAction.equalsIgnoreCase("up") && y - 1 >= 0				&& simulationstate.board[x][y - 1].freeCell()) {			return true;		}		else if (nextAction.equalsIgnoreCase("down")				&& y + 1 < simulationstate.sizey				&& simulationstate.board[x][y + 1].freeCell()) {			return true;		}		else if (nextAction.equalsIgnoreCase("left") && x - 1 >= 0				&& simulationstate.board[x - 1][y].freeCell()) {			return true;		}		else if (nextAction.equalsIgnoreCase("right")				&& x + 1 < simulationstate.sizex				&& simulationstate.board[x + 1][y].freeCell()) {			return true;		}		else {			return false;		}	}	private void filterFatique(AbstractGridSimulationAgentAction received,			WorldState simstate) {		GridSimulationWorldState simulationstate = (GridSimulationWorldState) simstate;		int failureActionProb = simulationstate.actionFailureProbability;		int maxFailureActionProb = simulationstate.maxActionFailureProbability;		int numberOfGoldItems = agentstate.currentItems;		int maxnumberOfGoldItems = simulationstate.maxNumberOfCarriedGoldItems;		// probability of action failure		int probability = this.computeProbability(failureActionProb,				maxFailureActionProb, maxnumberOfGoldItems, numberOfGoldItems);		int random = Math.abs(new Random().nextInt()) % 100;		// skip because of probability (not allowed in depot!)		if (random < probability && !agentstate.agentInDepot) {			received.type = "skip";			// PNO, 21.03.2007, also fatigue fail is FAIL and should be marked			// as such!			agentstate.actionFailed = true;		}	}	/**	 * This method computes for each agent his probabilty of action failure	 * 	 * @param fap	 *            failureActionProbability	 * @param mfap	 *            maxFailureActionProbability	 * @param mng	 *            maxNumberOfGoldItems	 * @param ng	 *            numberOfGoldItems (current)	 * @return value of probability	 */	public int computeProbability(int fap, int mfap, int mng, int ng) {		return (fap + ((mfap - fap) / mng) * ng);	}	/**	 * This method checks wether the agent collides with an other object.	 * 	 * @param x	 *            GridPosition x	 * @param y	 *            GridPosition y	 * @param sizex	 *            GridSize x	 * @param sizey	 *            GridSize y	 * @param board	 *            Grid	 * @return true when there is a collision and false when not	 */	private boolean collisionCheck(int x, int y, int sizex, int sizey,			GridSimulationCell[][] board) {		if (x < 0 || x >= sizex || y < 0 || y >= sizey) {			return true;		} else if (board[x][y].obstacle) {			return true;		}		// agent can not get in the depot without gold		else if (board[x][y].depot && !agentstate.agentHoldsGold) {			return true;		}		else if (board[x][y].depot && agentstate.agentHoldsGold) {			//agentstate.agentInDepot = true;			return false;		}		agentstate.agentInDepot = false;		return false;	}	/**	 * Converts a GridCell to a PerceptionCell	 * 	 * @param oldCell	 *            The GridCell	 * @return The new PerceptionCell	 */	private GridSimulationPerceptionCell convertCell(GridSimulationCell oldCell) {		GridSimulationPerceptionCell newCell = new GridSimulationPerceptionCell();		if (oldCell.agent) {			if (agentstate.team.equalsIgnoreCase(oldCell.agentTeam)) {				newCell.agentType = "ally";			} else {				newCell.agentType = "enemy";			}		}		newCell.agent = oldCell.agent;		newCell.depot = oldCell.depot;		newCell.gold = oldCell.gold;		newCell.mark = oldCell.mark;		if (oldCell.mark) {			newCell.markText = oldCell.markText;		}		newCell.obstacle = oldCell.obstacle;		return newCell;	}	/*	 * (non-Javadoc)	 * 	 * @see	 * massim.simulation.simplesimulation.SimulationAgent#createInitialPerception	 * (massim.simulation.simplesimulation.WorldState,	 * massim.simulation.simplesimulation.AgentState[])	 */	public InitialStickyPerception createInitialPerception(WorldState simstate,			AgentState[] agentstates) {		GridSimulationWorldState simulationstate = (GridSimulationWorldState) simstate;		GridSimulationAgentInitialPerception p = new GridSimulationAgentInitialPerception();		p.steps = simulationstate.numberOfSteps;		p.gsizex = simulationstate.sizex;		p.gsizey = simulationstate.sizey;		p.depotx = simulationstate.depotx;		p.depoty = simulationstate.depoty;		if (agentstate.team.equalsIgnoreCase(simulationstate.teamName[0])) {			p.opponent = simulationstate.teamName[1];		} else {			p.opponent = simulationstate.teamName[0];		}		return p;	}	/*	 * (non-Javadoc)	 * 	 * @see	 * massim.simulation.simplesimulation.SimulationAgent#createFinalPerception	 * (massim.simulation.simplesimulation.WorldState,	 * massim.simulation.simplesimulation.AgentState[])	 */	public FinalPerception createFinalPerception(WorldState simstate,			AgentState[] agentstates) {		GridSimulationAgentFinalPerception p = new GridSimulationAgentFinalPerception();		GridSimulationWorldState simulationstate = (GridSimulationWorldState) simstate;		int k = 0;		if (!agentstate.team.equalsIgnoreCase(simulationstate.teamName[k])) {			k = 1;		}		p.score = simulationstate.teamScore[k];		if (simulationstate.teamScore[0] == simulationstate.teamScore[1]) {			p.result = "draw";		} else if (simulationstate.teamScore[k] < simulationstate.teamScore[(k + 1) % 2]) {			p.result = "loose";		} else if (simulationstate.teamScore[k] > simulationstate.teamScore[(k + 1) % 2]) {			p.result = "win";		}		return p;	}}